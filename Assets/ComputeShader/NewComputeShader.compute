#pragma kernel CSMain
#pragma target 5.0

// Texture to write the Perlin noise values to
RWTexture2D<float4> Result;

// Constants for Perlin noise generation
#define TWO_PI 6.28318530717958647692
#define SCALE 1.0

// Hash lookup table used in Perlin noise generation
static const int perm[256] = { /* Permutation table here */ };

// Function to interpolate between values
float SmoothStep(float t)
{
    return t * t * (3.0 - 2.0 * t);
}

// Function to get a random value based on the permutation table
float random(float2 p)
{
    return frac(sin(dot(p, float2(12.9898, 78.233))) * 43758.5453);
}

// Function to get a random permutation value from the hash table
float2 hash(float2 p)
{
    float2 a = floor(p);
    float2 b = floor(p + float2(1.0, 1.0));
    float2 u = frac(p);
    u = u * u * (3.0 - 2.0 * u);
    
    return lerp(
        lerp(random(a), random(b), u.x),
        lerp(random(a + float2(0.0, 1.0)), random(b + float2(0.0, 1.0)), u.x),
        u.y);
}

// Function to generate Perlin noise value
float PerlinNoise(float2 p)
{
    float2 pi = floor(p);
    float2 pf = p - pi;
    
    float2 w = SmoothStep(pf);
    
    float a = dot(hash(pi), pf);
    float b = dot(hash(pi + float2(1.0, 0.0)), pf - float2(1.0, 0.0));
    float c = dot(hash(pi + float2(0.0, 1.0)), pf - float2(0.0, 1.0));
    float d = dot(hash(pi + float2(1.0, 1.0)), pf - float2(1.0, 1.0));
    
    return lerp(lerp(a, b, w.x), lerp(c, d, w.x), w.y);
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    // Calculate UV coordinates
    float2 uv = (id.xy + 0.5) / Result.GetDimensions();

    // Generate Perlin noise value
    float noiseValue = PerlinNoise(uv * SCALE);

    // Write result to texture
    Result[id.xy] = float4(noiseValue, noiseValue, noiseValue, 1.0);
}




//#pragma kernel CSMain
//#pragma target 5.0

//struct Cube
//{
//    float3 position;
//    float4 color;
//};

//float rand(float2 co)
//{
//    return (frac(sin(dot(co.xy, float2(12.9898, 78.233))) * 43758.5453)) * 1;
//}


//RWStructuredBuffer<Cube> cubes;
//float resolution;
//float repetitions;

//[numthreads(10, 1, 1)]
//void CSMain(uint3 id : SV_DispatchThreadID)
//{
    
//    for (int i = 0; i < repetitions; i++)
//    {
//        float xPos = id.x / resolution;
//        Cube cube = cubes[id.x];
    
    
//        float yPos = rand(float2(xPos, cube.position.z));
//        cube.position.y = yPos * 0.3f;
    
//        float r = rand(xPos * float2(cube.color.r, cube.color.g));
//        float g = rand(xPos * float2(cube.color.g, cube.color.b));
//        float b = rand(xPos * float2(cube.color.b, cube.color.r));
//        cube.color = float4(r, g, b, 1.0);
    
   
//        cubes[id.x] = cube;
//    }
//}
